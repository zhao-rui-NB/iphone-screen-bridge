#include "ADV7611.h"
#include "stm32f1xx_hal.h"
#include "stm32f1xx_hal_gpio.h"
#include <stdint.h>
#include <stdio.h>


// array size is 128
const uint8_t EDID_V1[]  = {
  0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x4a, 0xa9, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0x24, 0x01, 0x03, 0x80, 0x05, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x54, 0x22, 0xee, 0x2e, 0x20, 0x36, 0xfa, 0x51, 0x28, 0x03, 
  0x23, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc
};


// array size is 128
const uint8_t EDID_V2[]  = {
  0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x4a, 0xa9, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0x24, 0x01, 0x03, 0x80, 0x05, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x64, 0x19, 0xee, 0x2e, 0x20, 0x36, 0x38, 0x50, 0x28, 0x03, 
  0x23, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78
};


const uint8_t adv7611_edid_content[256] = {
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
    0x06, 0xD4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x16, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78,
    0x0A, 0x32, 0x30, 0xA1, 0x54, 0x52, 0x9E, 0x26,
    0x0A, 0x49, 0x4B, 0xA3, 0x08, 0x00, 0x81, 0xC0,
    0x81, 0x00, 0x81, 0x0F, 0x81, 0x40, 0x81, 0x80,
    0x95, 0x00, 0xB3, 0x00, 0x01, 0x01, 0x02, 0x3A,
    0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E,
    0xA9, 0x1A, 0x00, 0xA0, 0x50, 0x00, 0x16, 0x30,
    0x30, 0x20, 0x37, 0x00, 0xC4, 0x8E, 0x21, 0x00,
    0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x41,
    0x56, 0x4E, 0x45, 0x54, 0x2D, 0x45, 0x4D, 0x42,
    0x56, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4B, 0x20, 0x44, 0x11, 0x00, 0x0A,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x62,
    0x02, 0x03, 0x1F, 0x71, 0x4B, 0x90, 0x03, 0x04,
    0x05, 0x12, 0x13, 0x14, 0x1F, 0x20, 0x07, 0x16,
    0x26, 0x15, 0x07, 0x50, 0x09, 0x07, 0x01, 0x67,
    0x03, 0x0C, 0x00, 0x10, 0x00, 0x00, 0x1E, 0x01,
    0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E,
    0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x1E, 0x01, 0x1D, 0x80, 0x18, 0x71, 0x1C, 0x16,
    0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x9E, 0x8C, 0x0A, 0xD0, 0x8A, 0x20,
    0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80,
    0x3E, 0x73, 0x38, 0x2D, 0x40, 0x7E, 0x2C, 0x45,
    0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x1A,
    0x36, 0x80, 0xA0, 0x70, 0x38, 0x1F, 0x40, 0x30,
    0x20, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
};


void ADV7611_reset(){
    // high low high
    HAL_GPIO_WritePin(ADV7611_RST_GPIO_Port, ADV7611_RST_Pin, GPIO_PIN_SET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(ADV7611_RST_GPIO_Port, ADV7611_RST_Pin, GPIO_PIN_RESET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(ADV7611_RST_GPIO_Port, ADV7611_RST_Pin, GPIO_PIN_SET);
    HAL_Delay(10);
}

void ADV7611_read_reg(uint8_t addr, uint8_t reg, uint8_t *data){
    HAL_I2C_Mem_Read(&hi2c2, addr, reg, I2C_MEMADD_SIZE_8BIT, data, 1, HAL_MAX_DELAY);
}

void ADV7611_write_reg(uint8_t addr, uint8_t reg, uint8_t data){
    HAL_I2C_Mem_Write(&hi2c2, addr, reg, I2C_MEMADD_SIZE_8BIT, &data, 1, HAL_MAX_DELAY);
}

void ADV7611_set_edid(){

    // for(int i = 0; i < 128; i++){
    //     ADV7611_write_reg(ADV7611_EDID_ADDR, i, EDID_V1[i]);
    // }

    for(int i = 0; i < 128; i++){
        ADV7611_write_reg(ADV7611_EDID_ADDR, i, EDID_V2[i]);
    }

    // for(int i = 0; i < 256; i++){
    //     ADV7611_write_reg(ADV7611_EDID_ADDR, i, adv7611_edid_content[i]);
    // } // write

    ADV7611_write_reg(ADV7611_KSV_ADDR, 0x74, 0x01); // enable EDID
}


void ADV7611_Print_Debug_Status() {
    uint8_t val, val2;
    // uint16_t data16;
    
    printf("=== ADV7611 Debug Status ===\n");

    // 1. 檢查物理連接 (Cable Detect) - IO Map 0x6F [4]
    ADV7611_read_reg(ADV7611_IO_ADDR, 0x6F, &val);
    printf("Cable Detect (+5V): %s\n", (val & 0x01) ? "DETECTED" : "NONE");

    // 2. 檢查鎖定狀態 (PLL & Signal Lock) - IO Map 0x6A [5, 6]
    ADV7611_read_reg(ADV7611_IO_ADDR, 0x6A, &val);
    printf("TMDS PLL Locked:    %s\n", (val & 0x40) ? "YES" : "NO"); // Bit 6
    printf("TMDS Clock Detect:  %s\n", (val & 0x10) ? "YES" : "NO"); // Bit 4
    printf("Vertical Locked:    %s\n", (val & 0x02) ? "YES" : "NO"); // Bit 1
    printf("DE Regen Locked:    %s\n", (val & 0x01) ? "YES" : "NO"); // Bit 0 (Horizontal Lock)

    // 3. 檢查 HDMI/DVI 模式與加密 - HDMI Map 0x05 [7, 8]
    ADV7611_read_reg(ADV7611_HDMI_ADDR, 0x05, &val);
    printf("Input Mode:         %s\n", (val & 0x80) ? "HDMI" : "DVI");
    printf("Content Encrypted:  %s\n", (val & 0x40) ? "YES (HDCP)" : "NO");

    // 4. 測量輸入頻率 (TMDS Frequency) - HDMI Map 0x51, 0x52 [9, 10]
    // 頻率 = Integer part + Fractional part/128
    ADV7611_read_reg(ADV7611_HDMI_ADDR, 0x51, &val);  // Integer part
    ADV7611_read_reg(ADV7611_HDMI_ADDR, 0x52, &val2); // Fractional part
    float freq_mhz = val + ((val2 & 0x7F) / 128.0f);
    printf("TMDS Frequency:     %.2f MHz\n", freq_mhz);

    // 5. 檢查解析度參數 (STDI Measurements) - CP Map [11-15]
    // 這些值幫助我們判斷晶片"認為"輸入是什麼解析度
    
    // 讀取 Block Length (CH1_BL) - CP 0xB1, 0xB2
    ADV7611_read_reg(ADV7611_CP_ADDR, 0xB1, &val);
    ADV7611_read_reg(ADV7611_CP_ADDR, 0xB2, &val2);
    // Bit 13:0 are BL. Bit 14 is CH1_STDI_DVALID (Data Valid)
    uint8_t stdi_valid = (val & 0x80) >> 7; 
    uint16_t block_len = ((val & 0x3F) << 8) | val2;
    
    printf("STDI Valid:         %s\n", stdi_valid ? "YES" : "NO");
    if (stdi_valid) {
        printf("  Block Length:     %d (Ref: 1080p~8145, 720p~5091)\n", block_len);
        
        // 讀取 Lines per Field (CH1_LCF) - CP 0xA3, 0xA4
        ADV7611_read_reg(ADV7611_CP_ADDR, 0xA3, &val);
        ADV7611_read_reg(ADV7611_CP_ADDR, 0xA4, &val2);
        uint16_t lcf = ((val & 0x07) << 8) | val2;
        printf("  Lines per Field:  %d\n", lcf);
        
        // 讀取 Interlaced Status
        ADV7611_read_reg(ADV7611_IO_ADDR, 0x12, &val);
        printf("  Scan Mode:        %s\n", (val & 0x10) ? "Interlaced" : "Progressive");
    } else {
        printf("  (STDI仍在測量中或無訊號)\n");
    }

    // 6. 檢查 Free Run 狀態 - CP Map 0xFF [16, 17]
    ADV7611_read_reg(ADV7611_CP_ADDR, 0xFF, &val);
    printf("CP Free Run Status: %s\n", (val & 0x10) ? "FREE RUNNING (No Signal)" : "LOCKED (Normal)");
    
    printf("================================\n");
}

void ADV7611_Init(){

    printf("Resetting ADV7611...\n");
    ADV7611_reset();

    // read device id
    printf("Start reading ADV7611 Device ID...\n");
    uint8_t data_ea = 0;
    ADV7611_read_reg(ADV7611_IO_ADDR, 0xEA, &data_ea);
    uint8_t data_eb = 0;
    ADV7611_read_reg(ADV7611_IO_ADDR, 0xEB, &data_eb);
    printf("Device ID: %02X %02X\n", data_ea, data_eb);

    // set map
    // 98 FF 80 ; I2C reset
    // 98 F4 80 ; CEC
    // 98 F5 7C ; INFOFRAME
    // 98 F8 4C ; DPLL
    // 98 F9 64 ; KSV
    // 98 FA 6C ; EDID
    // 98 FB 68 ; HDMI
    // 98 FD 44 ; CP

    ADV7611_write_reg(ADV7611_IO_ADDR, 0xFF, 0x80); // I2C reset
    HAL_Delay(10);

    ADV7611_write_reg(ADV7611_IO_ADDR, 0xF4, 0x80); // CEC
    ADV7611_write_reg(ADV7611_IO_ADDR, 0xF5, 0x7C); // INFOFRAME
    ADV7611_write_reg(ADV7611_IO_ADDR, 0xF8, 0x4C); // DPLL
    ADV7611_write_reg(ADV7611_IO_ADDR, 0xF9, 0x64); // KSV
    ADV7611_write_reg(ADV7611_IO_ADDR, 0xFA, 0x6C); // EDID
    ADV7611_write_reg(ADV7611_IO_ADDR, 0xFB, 0x68); // HDMI
    ADV7611_write_reg(ADV7611_IO_ADDR, 0xFD, 0x44); // CP

    printf("ADV7611 io map addresses set.\n");

    
    // config ADV7611 registers
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x02, 0xf2); // Auto CSC, rgb out
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x03, 0x40); // 24 bit SDR 444 Mode 0
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x15, 0x80); // 

    
    // ADV7611_write_reg(ADV7611_IO_ADDR, 0x01, 0x06); // Prim_Mode =110b HDMI-GR
    // ADV7611_write_reg(ADV7611_IO_ADDR, 0x02, 0xF5); // Auto CSC, YCrCb out, Set op_656 bit
    // ADV7611_write_reg(ADV7611_IO_ADDR, 0x03, 0x40); // 24 bit SDR 444 Mode 0 
    // ADV7611_write_reg(ADV7611_IO_ADDR, 0x05, 0x28); // AV Codes Off
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x0B, 0x44); // Power up part
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x0C, 0x42); // Power up part
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x14, 0x7F); // Max Drive Strength
    // ADV7611_write_reg(ADV7611_IO_ADDR, 0x15, 0x80); // Disable Tristate of Pins
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x19, (0x80 +  26 )   ); // LLC DLL phase
    ADV7611_write_reg(ADV7611_IO_ADDR, 0x33, 0x40); // LLC DLL enable

    // HDMI Map (0x68)
    ADV7611_write_reg(ADV7611_HDMI_ADDR, 0x00, 0x00); // 選擇 Port A
    ADV7611_write_reg(ADV7611_HDMI_ADDR, 0x01, 0x00); // 關閉內部自動終端 (我們用手動)
    ADV7611_write_reg(ADV7611_HDMI_ADDR, 0x83, 0xFE); // 手動開啟 Port A 終端電阻 (Clock Term Enable)
    
    // HDMI 等化器 (Equalizer)
    ADV7611_write_reg(ADV7611_HDMI_ADDR, 0x96, 0x01); // 啟用動態等化器 // 好像沒幫助

    // edid
    ADV7611_set_edid();

    printf("ADV7611 initialization complete.\n");

}











